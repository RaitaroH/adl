#!/bin/bash

## Version: 2.2.4
## Wrapper for anime-donwloader. Allows using watchlist given by trackma for a better anime watching cli experience.
## Usage: $ adl [Option...] [Command]...
## Options:
##   -p, --player      Define player. Ex: $adl -p mpv
##   -s, --show        Watch custom show. Ep nr optional, careful with the quotes. Ex: $adl -s "gegege 2018" "70"
##   -h, --help        Display help.
##   -v, --version     Display version.

player="vlc"
check_player() { #{{{
  # Exit if "$player" is not installed
  if ! [ -x "$(command -v $player)" ]; then
    [[ -z $player ]] && echo "No argument provided." || echo "Error: $player is not installed." >&2
    print_help
    exit 1
  fi
  clear
} #}}}
watching_prompt() { echo -e "\nNow watching \033[0;34m$1\033[0m, $2 \033[0;34m$3 \033[0m" ;}
color_print()     { echo -e "\033[0;36m$@ \033[0m" ;} #for normal output
color_prompt()    { printf "\033[0;34m$@\033[0m" ;} #for user input
print_help()      { grep "^##" "$0" | sed -e "s/^...//" ;}
print_version()   { print_help | head -2 ;}
get_list()        { tlist=$(trackma list | head -n -2 | tail -n +2) ;}
# {{{
# Entry manipulation explination ...
# sed is removing color formating and everything untill the first letter it finds
# NR>1 ignore first line which is the header
# $1 is the title plus dots ... split allows to remove the dots, sets new result to var t
# $2 is Current / All episodes split allows to get the current episode number
# gsub thingy is to remove beggining space " 2" from one digit numbers
# $1=$2="" clears these two and prints $0 which prints $3, $4... Needed for x.x scores
# finally print t[1] = title and n[1] current episode number: result is like so:    Animu|x
# }}}

select_function() { #{{{
  # Retrieve title and nr. Parse file only once
  if [[ -z "$1" ]]; then
    entry="$(echo "$tlist" | fzf --ansi --reverse -m --prompt 'Multi-select with tab/shift-tab: ')"
    entry="$(echo "$entry" | sed 's/\x1b\[[0-9;]*m//g ; s/^[^A-Za-z]* //g' |\
      awk -F'  ' '{split($1,t,"."); gsub(" ", "", $2); split($2,n,"/"); $1=$2=""; gsub(" ", "", $0); print t[1]"|"n[1]"|"n[2]"|"$0}')"
    present=""
  else
    entry="$1" #retrieved custom show from adl input
    present="0"
  fi

  readarray -t lines <<< "$(echo "$entry")"
  for line in "${lines[@]}"; do
    watch "$line" "$present"
    echo
  done

} #}}}

watch() { #{{{
  title="$(echo "$1" | cut -d'|' -f1)"
  nr="$(($(echo "$1" | cut -d'|' -f2) + 1))" #dat spacing tho
   last="$(echo "$1" | cut -d'|' -f3)"
  score="$(echo "$1" | cut -d'|' -f4)"

  [[ -z "$title" ]] && color_print "Nothing was selected. Exiting." && return 1
  echo "$title > $(($nr-1)) / $last"

  color_print "Enter lowercase or uppercase to issue command:
    N - Next episode (default, press <ENTER>)
    L - from current to Last known
    A - All available, from episode 1
    R - Rewatch current episode only
    C - Custom episode
    S - Skip the watching. Straight to list update."
  color_prompt "Your choice? [N/l/a/r/c/s]: "
  read ans_episode
  case $ans_episode in
    ""|"n"|"N")
      watching_prompt "$title" "episode" "#$nr"
      { out=$(anime dl --play "$player" "$title" --episodes "$nr" 2> /dev/null | tee >(cat - >&5)); } 5>&1 ;;
    "l"|"L")
      if [[ "$last" != "?" ]]; then
        watching_prompt "$title" "starting with episode" "#$nr"
        { out=$(anime dl --play "$player" "$title" --episodes "$nr":"$last" 2> /dev/null | tee >(cat - >&5)); } 5>&1
      else
        color_print "The last episode number is unknown."
        color_prompt "How many episodes after currnet you want to watch? : "
        read ans_nr
        [[ $ans_nr != "" ]] && last=$(( $nr + $ans_nr)) || last=$(( $nr + 5))
        watching_prompt "$title" "episodes" "#$nr to #$last"
        { out=$(anime dl --play "$player" "$title" --episodes "$nr":"$last" 2> /dev/null | tee >(cat - >&5)); } 5>&1
      fi ;;
    "a"|"A")
      watching_prompt "$title" "starting with episode" "#1"
      { out=$(anime dl --play "$player" "$title" 2> /dev/null | tee >(cat - >&5)); } 5>&1 ;;
    "r"|"R")
      nr=$(($nr - 1))
      watching_prompt "$title" "episode" "#$nr"
      { out=$(anime dl --play "$player" "$title" --episodes "$nr" 2> /dev/null | tee >(cat - >&5)); } 5>&1 ;;
    "c"|"C")
      color_prompt "Enter custom number: "
      read nr
      watching_prompt "$title" "episode" "#$nr"
      { out=$(anime dl --play "$player" "$title" --episodes "$nr" 2> /dev/null | tee >(cat - >&5)); } 5>&1 ;;
    "s"|"S")
      color_print "Skipping watching episodes."
      color_prompt "Enter custom number: "
      read custom
      trackma update "$title" "$custom"
      trackma send
      sent="1"
      return 0 ;;
    *)
      color_print "Option not available."
      return 0 ;;
  esac

  # Initialize watched counter
  case $player in
    "vlc")
      watched=$(echo "$out" | grep 'Command Line Interface initialized' | wc -l) ;;
    "mpv")
      watched=$(echo "$out" | grep 'Playing: ' | wc -l) ;;
    *)
      watched=1 ;;
  esac
  [[ $watched == 0 ]] && color_print "\n$player didn't start, the anime wasn't found, or the episode wasn't found..." && return 0

  if [[ -z "$2" ]]; then #only ask if anime is in list
    color_prompt "\n\nIncrease nr in anime list? Yes, no, or custom number [Y/n/c]: "
    read ans_update
    case $ans_update in
      ""|"y"|"Y")
        [[ $ans_episode = "r" ]] || [[ $ans_episode = "R" ]] && color_print "No need to update..." && return 0 #exit if option r/R was used before
        [[ $watched -gt 1 ]] && color_print "\nadl counted $watched episodes that have been watched." && nr=$(( $watched + $nr - 1 ))
        if [[ $last == "?" ]]; then
           trackma update "$title" "$nr"
        else
          [[ $nr -le $last ]] && trackma update "$title" "$nr" || trackma update "$title" "$last"
        fi
        if [[ $score == 0 ]] && [[ $nr -ge $last ]] ; then
          color_prompt "\nAnime will be set to completed. Also rate the anime? Type score: "
          read ans_score
          [[ $ans_score != "" ]] && trackma score "$title" "$ans_score" || color_print "Skipping scoring..."
        fi
        trackma send
        sent="1"
        return 0 ;;
      "n"|"N")
        sent=""
        color_print "Skipping..."
        return 0 ;;
      "c"|"C")
        color_print "Enter custom number:"
        read custom
        trackma update "$title" "$custom"
        trackma send
        sent="1"
        return 0 ;;
      *)
        color_print "Option not available."
        return 0 ;;
    esac
  fi
} #end of watch() }}}

show_function() { #{{{
  if echo $tlist | grep -q "$1" ;then
    color_print "Anime found in list. Proceeding.\n"
    select_function "$(echo "$tlist" | grep "$1" | sed 's/\x1b\[[0-9;]*m//g ; s/^[^A-Za-z]* //g' |\
        awk -F'  ' '{split($1,t,"."); gsub(" ", "", $2); split($2,n,"/"); $1=$2=""; gsub(" ", "", $0); print t[1]"|"n[1]"|"n[2]"|"$0}')"
  else
    color_prompt "Anime not found in list. Want to add it? [y/N]: "
    read ans_add
    echo
    case $ans_add in
      "y"|"Y")
        trackma add "$1"
        trackma send
        color_print "\nRetrieving updated anime list...\n"
        get_list
        select_function ;; #anime is in list
      ""|"n"|"N")
        if [[ ! -z $2 ]]; then
          select_function "$1|$2|12|0" #episode nr was specified
        else
          color_print "Episode nr not specified. adl will proceed with a few guesses. Next time add the anime to list or run: \"\$adl 'TITLE' 'EPISODE'\""
          color_print "Episode nr can still be specified later using 'Custom' option.\n"
          select_function "$1|$2|12|0" #episode nr was specified
        fi ;;
    esac
  fi
} #}}}

watch_another() { #{{{
  while true; do #run as many episodes as possible one after another
    color_prompt "\nWant to watch another anime? [Y/n]: "
    read ans_another
    echo
    case $ans_another in
      ""|"y"|"Y")
        [[ -z $sent ]] || color_print "\nRetrieving updated anime list...\n" && get_list
        select_function ;;
      "n"|"N")
        color_print "Exiting.\n"
        exit 0 ;;
    esac
  done
} #}}}

while [ $# -ge 1 ]; do
  opt="$1"
  shift #next argument
  case "$opt" in
    -v|--version) print_version ; exit 0 ;;
    -h|--help)    print_help ; exit 0 ;;
    -p|--player)  player="$1" ;;
    -s|--show)
      if [[ -z $1 ]]; then
        echo "This options requires an argument!"
        print_help | tail -6
        exit 0
      else
       show_title="$1"
       show_episode="$2"
     fi ;;
  esac
  shift
done

check_player
get_list
[[ -z "$show_title" ]] && select_function || show_function "$show_title" "$show_episode"
watch_another
